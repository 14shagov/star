## 1. Единица количества информации. Биты и байты. Позиционные системы счисления. Двоичная, восьмеричная и шестнадцатеричная системы счисления.

**Бит** – это минимальная единица информации, принимающая два возможных значения (обычно 0 или 1). Бит используется для двоичного представления данных, где каждое значение соответствует логическому состоянию (выключено/включено). **Байт** – это группа из 8 битов (1 байт = 8 бит). Один байт может принимать 2^8 = 256 различных состояний (значений). Часто объёмы памяти или объём передаваемых данных измеряются в байтах и их кратных (килобайтах, мегабайтах и т.д.). Например, **килобайт (KB)** обычно считают равным 1024 байт, но по стандарту СИ килобайт = 1000 байт.

В **позиционных системах счисления** значение каждого цифрового разряда зависит от его позиции (разряда) в числе. Например, десятичная система (основание 10) – самая привычная: цифры 0–9, вес разряда равен степени 10. В **двоичной системе (основание 2)** используются цифры 0 и 1. Она применяется в цифровой электронике и компьютерах: любые числа записываются комбинацией 0 и 1. Например, двоичное число `1010₂` соответствует десятичному 10. Для перевода из двоичной в десятичную суммируют степени: 1010₂ = 1·2³ + 0·2² + 1·2¹ + 0·2⁰ = 8+0+2+0 = 10.

**Восьмеричная система (основание 8)** использует цифры 0–7. Она исторически применялась в программировании; три бита двоичного числа совпадают с одной цифрой восьмеричной, что упрощает преобразования (группа по 3 бита). Например, восьмеричное `75₈` = 7·8¹ + 5·8⁰ = 61₁₀. В C++ литералы в восьмеричной форме задаются с ведущим нулём: `075` означает 61 в десятичной.

**Шестнадцатеричная система (основание 16)** использует цифры 0–9 и буквы A–F (A=10,…,F=15). Она популярна в программировании (служит для компактного представления двоичных данных). Например, `3F₂₁₆` = 3·16¹ + 15·16⁰ = 63₁₀. В C++ шестнадцатеричные литералы записываются с префиксом `0x`, например, `0xFF` – это 255. Ниже приведены примеры C++-кода с числовыми литералами в разных системах:

```cpp
int b = 0b1011;  // двоичное (префикс 0b): 11
int o = 075;    // восьмеричное (префикс 0):    61
int h = 0xFF;   // шестнадцатеричное (префикс 0x): 255
```

## 2. Основные понятия (язык программирования).

**Язык программирования** – формальный язык для записи компьютерных программ. Он определяет набор правил (лексических, синтаксических и семантических) для описания алгоритмов, которые должен выполнить компьютер. Программа – это конкретная последовательность команд на языке программирования, реализующая некоторый алгоритм. **Алгоритм** – чётко заданный набор шагов (инструкций) для решения определённой задачи. Например, алгоритм сортировки или расчёта суммы чисел описывает, что именно и в каком порядке делать.

Язык программирования отличается от естественного тем, что предназначен для управления ЭВМ. Он требует точного соблюдения синтаксиса. Компилятор – программа, переводящая текст на языке высокого уровня (например, C++) в машинный код. Интерпретатор выполняет команды по мере чтения. C++ – компилируемый язык. В исходном коде C++ в файле `.cpp` мы пишем объявление функций, классов, переменных и т.д. Например, простейшая структура программы в C++ может выглядеть так:

```cpp
#include <iostream>     // подключаем библиотеку для ввода-вывода
int main() {
    // Тело программы: здесь инструкции выполняются последовательно
    std::cout << "Hello, World!" << std::endl;
    return 0;
}
```

Здесь `main` – главная функция, выполнение начинается с неё. Входные данные программа получает (например, через `std::cin`), выходные – выводит на экран или в файл. Обязательные понятия: **лексема** (элементарная единица текста: ключевое слово, идентификатор, число и т.д.), **синтаксис** (правила построения корректных конструкций) и **семантика** (значение конструкций). Понимание структуры программы (включая функции, условия, циклы и т.д.) необходимо для разработки алгоритмов на C++.

## 3. Алфавит C++. Идентификаторы. Объявление констант и переменных.

**Алфавит языка C++** – множество символов, разрешённых в тексте программы. Он включает прописные и строчные латинские буквы (`A`–`Z`, `a`–`z`), цифры `0`–`9`, знак подчёркивания `_` и некоторые специальные символы (`{},.;:+-*/%&|^<>=()[]#!\\?\"'` и др.). Остальные символы (например, кириллица) могут использоваться только внутри символьных или строковых литералов и комментариев. C++ **чувствителен к регистру**: идентификаторы `Var` и `var` – разные объекты.

Идентификатор – это имя переменной, функции, класса и т.д. . Он должен начинаться с буквы или `_` (не с цифры) и может содержать буквы, цифры и знак подчёркивания. Например, `count`, `_index`, `MaxValue123` – допустимые имена. Идентификаторы не могут совпадать с ключевыми словами (например, `int`, `for`, `class`). Идентификатор именует объект в программе: переменную, функцию, метку, тип и т.п. .

**Константа** – это символическое имя или литерал, значение которого неизменно во время работы программы. В C++ константу объявляют ключевым словом `const` или с помощью `constexpr`, например:

```cpp
const double PI = 3.1415926535;  // объявление константы с именем PI
```

Здесь `PI` – константа типа `double`, ей присвоено фиксированное значение. Константы могут быть числовыми, символьными (`char c = 'A';`), строковыми (`const std::string s = "Hello";`) и т.д.

**Переменная** – это именованный объект (ячейка памяти), предназначенный для хранения изменяемых данных. Перед использованием переменную нужно объявить, указав её тип и имя, например:

```cpp
int count;       // объявление целочисленной переменной count
count = 10;      // присваиваем ей значение 10
```

Переменная может менять своё значение в процессе выполнения программы (например, через операцию присваивания `=`). Объявление переменной резервирует память в соответствии с её типом. Например, `int x;` резервирует (обычно 4 байта) для хранения целого числа. Для числовых типов можно использовать модификаторы `signed`/`unsigned` (знаковость) и указать размер (`short`, `long`).

## 4. Структура программы в С++. Основные операторы. Составные операторы. Выражения, операции.

Структура программы на C++ обычно включает: *директивы препроцессора* (`#include` для подключения библиотек, `#define` для макроконстант), **функции**, включая обязательную `main()`, и объявления глобальных объектов. Базовый шаблон программы:

```cpp
#include <iostream>
using namespace std;

int main() {
    // тело программы: здесь последовательно выполняются операторы
    return 0;
}
```

Здесь `int main()` – точка входа. Перед `main` могут идти объявления функций, классов, глобальных переменных. В теле `main` (и других функций) пишутся **операторы** – инструкции языка. Примеры основных операторов: присваивания (`=`), арифметические (`+`, `-`, `*`, `/`, `%`), ввод-вывод (`std::cin`, `std::cout`), условные (`if`), циклические (`for`, `while` и т.д.), переходы (`break`, `continue`, `return`), и др.

Составной оператор (блок) заключается в `{}` и позволяет сгруппировать несколько операторов в одно целое. Например:

```cpp
{
    int a = 1;
    int b = 2;
    int sum = a + b;
}
```

Этот блок `{ ... }` рассматривается как единый составной оператор. Блоки используются в функциях, условиях, циклах для объединения нескольких операторов.

**Выражение** – комбинация переменных, констант, функций и операций, которая вычисляет некоторое значение. Выражения могут включать операторы и операнды. Пример выражения: `(a + b) * 2`. В C++ выражения используются для вычисления значений и присваиваний. Операция – это отдельный оператор, например, `+` (сложение), `*` (умножение), `==` (сравнение) и т.д. Ключевое отличие: оператор – это символ действия, а выражение – полная конструкция, дающая результат. С помощью выражений и операторов строятся все вычисления в программе.

## 5. Концепция типов данных. Простейшие и стандартные типы данных. Основные свойства.

**Тип данных** – характеристика множества возможных значений и операций над ними. Тип определяет: какие значения может принимать переменная и что с ними можно делать. Например, тип `int` означает множество целых чисел (обычно от –2³¹ до 2³¹–1) и операции над ними (сложение, вычитание и т.д.). C++ – статически типизированный язык: тип переменной указывается при объявлении и не меняется.

Простейшие (базовые) типы данных в C++ (из стандарта) включают:

* **Логический**: `bool` – хранит `true` или `false` (обычно 1 байт).
* **Символьные**: `char` – 1 байт, хранит символы (обычно ASCII); `wchar_t`, `char16_t`, `char32_t` – расширенные типы для Unicode-систем (2 или 4 байта).
* **Целочисленные**: несколько вариантов по размеру: `short` (обычно 2 байта), `int` (обычно 4 байта), `long` (4 или 8 байт) и `long long` (8 байт). Для каждого из них бывают знаковый (`signed`) и беззнаковый (`unsigned`) варианты, влияющие на диапазон. Диапазоны приведены в таблице:

  * `signed char`: –128…127 (1 байт), `unsigned char`: 0…255 (1 байт).
  * `short int`: –32768…32767 (2 байта), `unsigned short`: 0…65535 (2 байта).
  * `int`: обычно –2 147 483 648…2 147 483 647 (4 байта).
  * `long int`: –2 147 483 648…2 147 483 647 (4 байта, на многих системах).
  * `long long int`: –9 223 372 036 854 775 808…+9 223 372 036 854 775 807 (8 байт).
    Беззнаковые аналоги (`unsigned int` и т.д.) имеют диапазон от 0 до 2^N–1 (см. таблицу).
* **Вещественные (с плавающей точкой)**: `float` (4 байта, приблизительный диапазон \~10^–38…10^38) и `double` (8 байт, диапазон \~10^–308…10^308). Также `long double` – расширенный (обычно ≥8 байт). Эти типы хранят дробные числа.
* **Пустой тип**: `void` – особый тип, означающий «нет значения»; используется для функций без возвращаемого значения и указателей на неуказанный тип.
* **Перечислимый тип**: `enum` – задаётся пользователем как набор именованных целых констант (подмножество целых).
* **Строковый тип**: `std::string` (из стандартной библиотеки `<string>`) – класс для работы с текстовыми строками произвольной длины. Также есть C-строки (`char`-массивы с завершающим `\0`), но `std::string` безопаснее и удобнее.

Главное свойство типов – определённый размер и диапазон представимых значений. Например, для `int` размер зависит от компилятора, но стандарт гарантирует минимум 2 байта. Типы статически проверяются компилятором: вы не можете присвоить `std::string` в переменную типа `int` без явного преобразования. Это позволяет избегать ошибок при компиляции. Таблица размеров и диапазонов стандартных типов приведена выше.

## 6. Символьные и строковые типы данных. Особенности. Примеры.

**Символьный тип данных**: в C++ базовый символьный тип – `char` (обычно 1 байт, 8 бит). Переменная `char` хранит один символ (например, `char c = 'A';`) и фактически содержит числовой код этого символа (обычно по ASCII, где `'a'` имеет код 97). Символьные константы записываются в одинарных кавычках: `'x'`, `'7'`, `'\n'` и т.д. Кроме `char` в C++ существуют «широкие» символьные типы:

* `wchar_t` – расширенный символьный тип (обычно 2 байта, хранит символ Unicode).
* `char16_t` (2 байта) и `char32_t` (4 байта) – добавлены в C++11 для поддержки символов Unicode UTF-16 и UTF-32 соответственно. Например, `char16_t u = u'Ж';` хранит символ 'Ж'. С вводом Unicode стало возможным хранить символы разных языков.

**Строковый тип данных**: в C++ для работы со строками обычно используют класс `std::string` (заголовок `<string>`). Строковый литерал заключается в двойные кавычки (например, `"Hello"`). Строка – это последовательность символов `char` (в памяти завершается нулевым символом `\0`). Например:

```cpp
std::string s = "Hello, world!";   // строковая переменная
const char* cstr = "Test";         // C-строка (указатель на массив char)
```

В отличие от одного символа, строковый литерал (например, `"Hello"`) имеет тип `const char*` или `std::string` при инициализации. По строкам можно выполнять операции конкатенации, сравнения, поиск и т.д. Важная особенность: строковый литерал `"Hello"` эквивалентен константному массиву `{'H','e','l','l','o','\0'}`.  Подчёркиваем разницу: символ (типа `char`) берётся в одинарные кавычки, а строка (последовательность символов) – в двойные.

Примеры в C++:

```cpp
char ch = 'A';                      // один символ
char16_t u16 = u'Ж';               // 16-битный Unicode-символ
std::string str1 = "Привет";        // строка на русском
std::wstring wstr = L"Привет";      // std::wstring с широкими символами
```

Здесь `L` перед кавычками задаёт широкую строку (`std::wstring`) с типом `wchar_t`.

## 7. Задание случайных величин. Примеры.

Для генерации псевдослучайных чисел в C++ есть функции из `<cstdlib>` и возможности из C++11 (`<random>`). Функция `rand()` возвращает целое число в диапазоне от 0 до `RAND_MAX` (обычно 32767). Однако последовательность чисел от `rand()` детерминирована (всегда одна и та же без инициализации). **Сидирование** задаёт начальное значение генератора: `srand(seed)`. Обычно перед первым вызовом `rand()` устанавливают `srand(time(0))` (из `<ctime>`), чтобы при каждом запуске программы использовался разный старт. Пример:

```cpp
#include <cstdlib> 
#include <ctime> 
srand(static_cast<unsigned>(time(NULL))); // инициализируем по текущему времени
int r = rand();             // случайное число 0..RAND_MAX
int r100 = rand() % 100;    // случайное число 0..99
double x = static_cast<double>(rand())/RAND_MAX; // 0.0..1.0
```

В этом примере `rand()%100` даёт равномерное целое от 0 до 99. Чтобы получать числа в другом диапазоне \[a..b], можно использовать `a + rand() % (b-a+1)` при равномерном распределении.

Начиная с C++11 в `<random>` добавлен более мощный функционал: генераторы и распределения (напр. алгоритм Мерсенна `std::mt19937`, равномерные `std::uniform_int_distribution`, распределение Пуассона и др.). Пример использования нового подхода:

```cpp
#include <random>
std::mt19937 gen(std::random_device{}()); // генератор Вихрь Мерсенна
std::uniform_int_distribution<int> dist(1, 100); // равномерное 1..100
int r = dist(gen);  // случайное число 1..100
```

Это даёт более качественные случайные числа и гибкость: можно задавать разные распределения (равномерное, нормальное и т.д.).

## 8. Циклы с параметром. Примеры.

**Цикл с параметром** в C++ – это цикл `for`, в котором заранее задаётся счетчик итераций. Общий вид:

```cpp
for (инициализация; условие; шаг) {
    // тело цикла
}
```

Здесь `инициализация` – обычно присвоение начального значения переменной-счетчика (например, `int i = 0`), `условие` – логическое выражение, при `false` которого цикл прерывается, а `шаг` – изменение счетчика после каждой итерации (`i++`, `i+=2` и т.д.). Цикл выполняет тело повторно, пока условие истинно. Например:

```cpp
for (int i = 1; i <= 5; i++) {
    std::cout << i << " ";
}
```

Выведет числа `1 2 3 4 5`. Здесь счётчик `i` последовательно принимает значения 1,2,3,4,5. После каждой итерации увеличиваем `i` на 1. Если условие сразу ложно (например, `for(int i=10; i<5; i++)`), тело цикла не выполняется ни разу. Цикл `for` особенно удобен, когда число повторений заранее известно или вычисляется по известным данным. Его можно использовать и для перебора элементов массива по индексу и т.д.

## 9. Циклы. Предусловие. Примеры.

Цикл **с предусловием** в C++ – это `while`. Условие проверяется перед каждой итерацией. Если условие истинно, выполняется тело цикла; если ложно – цикл завершается. Синтаксис:

```cpp
while (условие) {
    // тело цикла
}
```

Например:

```cpp
int i = 0;
while (i < 5) {
    std::cout << i << " ";
    i++;
}
```

Этот код выведет `0 1 2 3 4`. Переменная `i` последовательно принимает значения 0…4. Сначала проверяем `i < 5`; если истина, выполняем тело и увеличиваем `i`. Как только условие станет ложным (`i` станет 5), выход из цикла. Цикл `while` удобно применять, когда количество итераций заранее неизвестно, а решение о продолжении цикла принимается на каждой итерации. Например, считывать с клавиатуры значения, пока пользователь не введёт 0:

```cpp
int x;
std::cin >> x;
while (x != 0) {
    // обрабатываем x
    std::cin >> x;
}
```

Тут сначала читается `x`, и пока `x` не равно 0, тело цикла выполняется.

## 10. Циклы. Постусловие. Примеры.

Цикл **с постусловием** в C++ – это `do...while`. Здесь условие проверяется после выполнения тела, поэтому тело выполняется **минимум один раз**. Синтаксис:

```cpp
do {
    // тело цикла
} while (условие);
```

Например:

```cpp
int x;
do {
    std::cin >> x;
    std::cout << x << "\n";
} while (x != 0);
```

В этом примере сначала выполняется ввод и вывод, а затем проверяется условие `x != 0`. Если `x` всё ещё не 0, тело повторится. Таким образом, пользователь гарантированно сможет ввести число хотя бы один раз. По сравнению с `while`, `do...while` чаще используют, когда требуется, чтобы тело выполнилось хотя бы один раз (например, меню программы, в котором запрос на действие делается перед проверкой условий выхода).

Отлично. Я продолжу подробный пошаговый разбор экзаменационных вопросов с 11 по 20, придерживаясь того же стиля и структуры, что и ранее — с пояснением всех ключевых понятий, примерами кода на C++, логическими таблицами и схемами, если требуется.

Далее будет представлена вторая часть шпаргалки по вопросам 11–20.


# 11. Ветвления. Виды. Примеры.

В программировании *ветвление* – это базовая структура, при которой выполнение или невыполнение некоторого набора команд зависит от условия. В C++ для организации ветвления используются главным образом два оператора: **`if`** (условный оператор) и **`switch`** (множественный выбор). Оператор `if` проверяет логическое условие и выполняет соответствующий блок кода, оператор `switch` выбирает один из нескольких вариантов исполнения на основании значения выражения.

* **Оператор `if`**: проверяет условие в скобках. Если оно истинно (ненулевое/`true`), выполняется блок сразу после `if`; иначе, при наличии, выполняется блок после `else`. Можно писать цепочку `if ... else if ... else`. Пример:

  ```cpp
  int x = 5;
  if (x > 0) {
      std::cout << "x положительное\n";
  } else if (x == 0) {
      std::cout << "x ноль\n";
  } else {
      std::cout << "x отрицательное\n";
  }
  ```

  Так `if`-оператор обеспечивает ветвление кода по условию. Как отмечено в описании, оператор `if-else` “управляет условным ветвлением” программы.

* **Оператор `switch`**: предназначен для выбора одного из нескольких вариантов на основе целочисленного (или `char`) выражения. Он рассматривает значение выражения и передает управление соответствующему `case`. Обычно используется с `break` после каждого `case`. Пример:

  ```cpp
  char op = '+';
  int a = 4, b = 2;
  int result = 0;
  switch(op) {
      case '+': result = a + b; break;
      case '-': result = a - b; break;
      case '*': result = a * b; break;
      case '/': result = a / b; break;
      default:  std::cout << "Неверный оператор\n";
  }
  std::cout << result;
  ```

  Здесь `switch` выбирает и выполняет блок по совпадению `op`. Оператор `switch` также относится к ветвлению – он «помогает управлять сложными условными операциями и операциями ветвления».

**Итого:** операторы ветвления позволяют программе «разветвлять» выполнение в зависимости от условий. Основные виды ветвлений в C++ – это `if/else` (простое и каскадное ветвление) и `switch/case` (множественный выбор). Примерные коды приведены выше.

# 12. Массивы. Основные свойства. Примеры.

**Массив** – это структура данных для хранения фиксированного числа элементов одного типа последовательно в памяти. Как сказано в справочных материалах, «массив представляет собой последовательность объектов одного и того же типа, которые занимают непрерывную область памяти». Каждый элемент массива имеет индекс (обычно целое число), по которому к нему обращаются, начиная с 0. Основные свойства массива:

* Однотипность элементов. Все элементы массива имеют один тип (например, `int`, `double` и т.д.).
* Непрерывность в памяти. Доступ к любому элементу осуществляется за константное время (арифметикой указателей), поскольку элементы хранятся «рядом».
* Фиксированный размер. При статическом объявлении длину массива нужно задать константным выражением; она не меняется во время работы программы.
* Индекс начинается с 0. Первый элемент имеет индекс 0, последний – индекс (размер–1).

Например, объявление массива из 5 целых:

```cpp
int arr[5] = {10, 20, 30, 40, 50}; 
```

создаёт 5 подряд идущих `int`. Доступ:

```cpp
std::cout << arr[0];   // первый элемент (10)
arr[4] = 100;          // пятый элемент изменён на 100
```

Можно перебирать элементы в цикле:

```cpp
for(int i = 0; i < 5; i++){
    std::cout << arr[i] << " ";
}
```

Многомерные массивы (например, матрицы) объявляются как массив массивов:

```cpp
double mat[3][4]; // матрица 3×4 double
mat[1][2] = 3.14;
```

Важно помнить, что массив как структура данных обеспечивает *произвольный доступ* к элементам (любому индексу) за одинаковое время. Однако статические массивы нельзя «расширить» или «сжать» без копирования. Для гибкости в современном C++ часто применяют `std::vector` или `std::array`, но базовый массив – простая и эффективная структура.

# 13. Структуры. Основные свойства. Примеры.

**Структура** (`struct`) в C++ – это пользовательский тип данных, который объединяет под одним именем несколько полей (членов) разного (или одного) типа. Другими словами, она позволяет *сгруппировать переменные разных типов в единое целое*. Это удобно для объединения логически связанных данных. При объявлении структуры перечисляют её поля, но память под них выделяется лишь при создании переменной этого типа. Например:

```cpp
struct Person {
    std::string name;
    int age;
    double weight;
};
```

Здесь `Person` – новый тип, содержащий `name`, `age`, `weight`. Само объявление структуры не выделяет память (оно лишь описывает формат). Память резервируется при создании переменной:

```cpp
Person p;
p.name = "Alice";
p.age = 30;
p.weight = 65.5;
std::cout << p.name << " " << p.age;
```

Доступ к полям осуществляется через оператор `.` (точка). Можно создать несколько экземпляров:

```cpp
Person alice, bob;
alice.name = "Alice";
bob.name = "Bob";
```

В C++ `struct` очень похожа на класс (единственное формальное отличие – по умолчанию поля `struct` публичные, а у `class` – приватные). Структуры могут включать методы, конструкторы и даже наследовать другие структуры, но чаще используются для простого объединения данных.

**Основные свойства структур:** они являются составными типами данных, группируют поля, доступны по именам полей, передаются в функции по значению или ссылке целиком (копируя все поля). Структуру можно инициализировать списком (C++11):

```cpp
Person john = {"John", 25, 70.0};
```

С помощью структур удобно описывать записи (например, «сотрудник», «точка», «запись в телефонной книге»).

# 14. Подпрограммы (всё о параметрах). Функции. Примеры.

**Подпрограмма** (процедура или функция) – это именованный блок кода, выполняющий определённую задачу. Она принимает *параметры* (аргументы) и, возможно, возвращает результат. Подпрограммы (функции) помогают избежать дублирования кода и структурировать программу.

**Параметры функции:** формальные параметры перечисляются в заголовке функции после имени и типа. Параметр – это переменная, от значения которой зависит работа подпрограммы. При вызове функции передаются *аргументы* – конкретные значения. Если параметр объявлен просто по типу (например, `int x`), то передача по умолчанию идёт **по значению** – создаётся локальная копия. Пример передачи по значению:

```cpp
void increment(int a) {
    a = a + 1; // изменит только локальную копию
}
```

Если же нужно, чтобы функция изменила исходную переменную, используют **передачу по ссылке** (или по указателю). При передаче по ссылке параметр объявляется с `&`:

```cpp
void increment(int &a) {
    a = a + 1; // изменение повлияет на оригинал
}
```

Вызов `increment(x)` в первом случае не изменит `x` в вызвавшей функции, а во втором – изменит, как указано: изменения через ссылку отражаются на исходной переменной. Также возможна передача по указателю (`int* ptr`).
C++ также поддерживает **параметры с умолчанием** (default), передача константных ссылок (для оптимизации больших структур/классов), переменное число параметров (varargs) и т.д.

Кроме параметров, у функции обычно есть возвращаемое значение. Если функция возвращает значение, у неё есть оператор `return`. Процедуры (типа `void`) просто выполняют действие без возвращаемого результата. Пример функции с параметрами:

```cpp
int add(int a, int b) {
    return a + b;
}
...
int sum = add(3, 4); // sum == 7
```

**Подытожим:** подпрограмма (функция) – это именованный блок кода, принимающий параметры (входные значения) и, возможно, возвращающий результат. Параметры могут быть переданы по значению (копируются), по ссылке (меняют оригинал) или по указателю. Как поясняется, «Параметр – это переменная, от значения которой зависит работа подпрограммы», а аргумент – конкретное значение, передаваемое функции при вызове.

# 15. Сохранение и чтение данных из текстовых файлов.

Для работы с текстовыми файлами в C++ используют библиотеки `<fstream>`. Классы **`std::ifstream`** и **`std::ofstream`** предназначены для чтения из файла и записи в файл соответственно. Обычно поток создаётся с указанием имени файла в конструкторе:

```cpp
#include <fstream>
std::ifstream fin("input.txt");   // открыть файл для чтения
std::ofstream fout("output.txt"); // открыть файл для записи
```

После открытия с объектами можно работать так же, как с `std::cin` и `std::cout`. Например:

```cpp
int a, b;
fin >> a >> b;          // считываем два числа из input.txt
fout << a + b << "\n";  // записываем результат в output.txt
```

После окончания следует закрыть файлы: `fin.close(); fout.close();`, хотя деструкторы потоков обычно делают это автоматически. Для чтения строк используют `std::getline`:

```cpp
std::string line;
std::getline(fin, line); // считывает одну строку из файла
```

Повторяя `getline` в цикле `while (std::getline(fin, line)) { ... }`, можно построчно прочитать весь файл. Проверить конец файла можно через `fin.eof()` или через результат операций чтения.

Таким образом, запись/чтение из текстовых файлов заключается в открытии потока `ofstream`/`ifstream` и использовании операторов `<<`/`>>` (или `getline`) аналогично стандартному вводу-выводу. Как указано, после работы файлы нужно закрыть. Этот подход позволяет сохранять и восстанавливать данные между запусками программы.

# 16. Понятие рекурсии. Рекурсивные алгоритмы. Виды рекурсии. Примеры и сравнение рекурсивных и итеративных алгоритмов.

**Рекурсия** – это когда функция вызывает саму себя (непосредственно или косвенно) для решения более простой версии задачи. Иначе говоря, рекурсивная функция решает задачу «своей копией» с новыми параметрами. Функция должна иметь условие прекращения (базовый случай), чтобы избегать бесконечных вызовов.

* *Прямая рекурсия:* функция вызывает саму себя.
* *Косвенная рекурсия:* функция A вызывает функцию B, а та в итоге вызывает A.
  Например, прямая рекурсия:

```cpp
int fact(int n) {
    if (n <= 1) return 1;       // базовый случай
    return n * fact(n - 1);    // рекурсивный вызов
}
```

(Здесь `fact` вызывает себя.) А косвенная – когда, скажем, `foo()` вызывает `bar()`, а `bar()` вызывает `foo()`.

Рекурсивные алгоритмы удобны для задач, естественно разбивающихся на подобные подзадачи: обход дерева, вычисление факториала, чисел Фибоначчи, поиск в графе и т.п. Но они имеют накладные расходы: при каждом вызове резервируется стековая память для параметров и локальных переменных. Как отмечено, для каждого рекурсивного вызова «в стек вызовов записывается вся информация, связанная с этим вызовом» и контексты предыдущих вызовов остаются в памяти. Если глубина рекурсии очень велика или терминальное условие не достигнуто, возможен *stack overflow* (переполнение стека) и аварийное завершение.

Рекурсия делится также на *хвостовую* (tail recursion, когда рекурсивный вызов – последняя операция) и обычную. Хвостовая рекурсия может быть оптимизирована компилятором (например, заменена на цикл), но в стандартном C++ это не гарантируется.

**Пример рекурсии:** классический – вычисление факториала и чисел Фибоначчи:

```cpp
int fib(int n) {
    if (n <= 1) return n;
    return fib(n-1) + fib(n-2);
}
```

Эта рекурсия на каждом шаге вызывает себя дважды. Итеративная (циклическая) версия того же алгоритма (с помощью цикла) обычно более эффективна по памяти и времени, так как рекурсивный вариант многократно вычисляет одни и те же значения.

**Сравнение с итерацией:** Рекурсивный алгоритм часто проще для понимания и написания при соответствующей задаче, но менее эффективен в использовании ресурсов. Итеративный алгоритм (на основе циклов) обычно быстрее и не требует глубокого стека. Как образно поясняется в источниках, рекурсивный процесс «откладывает вычисления на потом», накапливая информацию в стеке, тогда как итеративный делает всё «при первой возможности», не требуя дополнительной памяти. Поэтому рекурсия дает гибкость и лаконичность, но может «съедать» больше памяти и выполнять больше операций. Итеративная реализация, как правило, предпочтительнее по производительности, если задача допускает простой цикл.

# 17. Тестирование и отладка. Общие подходы, их достоинства и недостатки.

**Тестирование** – это процесс проверки программы с целью выявления ошибок и несоответствий требованиям. **Отладка** – это процесс диагностики и исправления найденных ошибок. Тестирование систематически выявляет дефекты (баги), а отладка фокусируется на локализации и исправлении этих ошибок. Примерно: «тестирование – поиск ошибок, отладка – исправление».

*Подходы к тестированию и отладке:*

* **Модульное (unit) тестирование:** проверка отдельных функций/классов. Преимущества: изолирует ошибки, автоматизируемо (фреймворки типа GoogleTest). Недостатки: требует написания тестов, может не охватывать интеграцию модулей.
* **Интеграционное и системное тестирование:** проверка взаимодействия модулей и всей системы. Позволяет найти проблемы взаимодействия, но сложнее настроить, может пропустить мелкие ошибки в отдельных модулях.
* **Ручное тестирование:** воспроизведение действий пользователя. Гибкость, наглядность – но трудоёмко, зависит от человека, возможны пропуски.
* **Автоматизированное тестирование:** скрипты, тестовые сценарии. Эффективно для регрессии (повторяемость), быстро выполняется, но требует времени на разработку сценариев.
* **Статический анализ кода/ревью:** чтение кода, инструменты типа линтеров. Помогают найти дефекты без запуска. Достоинства – раннее обнаружение ошибок, недостатки – не ловят логические ошибки, зависят от качества инструментов.
* **Отладка с помощью логирования и дебаггера:** например, постановка точек останова, просмотр переменных. Позволяет детально анализировать выполнение. Минусы – может быть медленной и требовать «ручного» вмешательства.
* **Тестирование «чёрного ящика»:** проверка функционала без знания внутренней структуры (с точки зрения пользователя или спецификации). Достоинство – не зависит от кода, выявляет несоответствие требованиям. Недостаток – не гарантирует покрытие всех путей, сложнее отловить «внутренние» ошибки.
* **Тестирование «белого ящика»:** основано на знании кода (например, контроль покрытий ветвлений). Достоинство – можно целенаправленно тестировать все ветви и условия, недостаток – не всегда легко составить тесты, может упустить внешний вид и пользовательский сценарий.

Каждый подход имеет свои плюсы и минусы: комбинированное тестирование (например, и ручное, и автоматическое, черного и белого) даёт более надёжный результат. Важно проводить тестирование и отладку последовательно: найти ошибку в тестах – потом отладить её в коде.

# 18. Тестирование и отладка. Методы «чёрного» и «белого ящика», «сэндвич».

**Тестирование «чёрного ящика»** (black-box) – подход, когда тестировщик не знает внутреннего устройства кода. Он тестирует систему «снаружи», как обычный пользователь, оценивая функциональность. Тестовые случаи строятся на основе требований и спецификаций, без учёта структуры кода. Это позволяет найти ошибки в логике, интерфейсе и обработке некорректного ввода. К плюсам черного ящика относят простоту применения и независимость от реализации; к минусам – невозможность проверить внутренние ветвления и может быть пропуск скрытых ошибок.

**Тестирование «белого ящика»** (white-box) – подход, основанный на анализе внутренней структуры программы. Тестировщик знаком с кодом и может написать тесты, которые проверяют все важные ветви, условия, циклы. Это позволяет обеспечить высокое покрытие кода тестами. Однако требует знаний языка/архитектуры и значительных усилий по написанию тестов. Также тесты могут быть склонны к «привязке» к текущей реализации и не уловить несоответствие ТЗ.

**Метод «сэндвича»** – это способ интеграционного тестирования, сочетающий подходы сверху и снизу. По методу сэндвича одновременное **нисходящее** (top-down) и **восходящее** (bottom-up) тестирование ведутся параллельно до «середины» программы. Система как бы собирается одновременно с двух сторон («наверх» и «вниз») и встречается в центре. Это компромисс между двумя подходами: убираются ограничения чисто сверху (где нечего тестировать без нижних модулей) и снизу (где сложно достроить взаимодействия без верхних модулей). Метод сэндвича даёт более сбалансированную проверку взаимосвязей между модулями.

Таким образом, **черный** и **белый ящик** – это разные точки зрения на тестирование (внешняя и внутренняя), а метод **сэндвича** – способ интеграционного тестирования, сочетающий и «вниз» (модули целиком), и «вверх» (верхний уровень) подход.

# 19. Логические выражения и операции. Таблицы истинности.

**Логическое выражение** – это формула, составленная из логических переменных (истина/ложь, 1/0) с помощью логических операций. В C++ к ним относятся операции И (`&&`), ИЛИ (`||`), НЕ (`!`) и др. (например, исключающее ИЛИ – `^`). Каждое логическое выражение можно проиллюстрировать **таблицей истинности** – таблицей, описывающей значение функции при всех комбинациях входных переменных.

Основные логические операции:

* **Конъюнкция (И, AND)** – результат истинен только когда все операнды истинны.
* **Дизъюнкция (ИЛИ, OR)** – истина, если хотя бы один операнд истинен.
* **Отрицание (НЕ, NOT)** – унарная операция, инвертирует значение: `!true = false`, `!false = true`.
* **Исключающее ИЛИ (XOR)** – истина, если операнды различны.
* **Прочие** (импликация, эквиваленция, NAND/NOR и др.) встречаются реже.

Ниже приведены таблицы истинности для основных операций на двух переменных (0 – ложь, 1 – истина):

|  A  |  B  | A && B | A \|\| B |
| :-: | :-: | :----: | :------: |
|  0  |  0  |    0   |     0    |
|  0  |  1  |    0   |     1    |
|  1  |  0  |    0   |     1    |
|  1  |  1  |    1   |     1    |

|  A  |  !A |
| :-: | :-: |
|  0  |  1  |
|  1  |  0  |

|  A  |  B  | A ^ B | (A XOR B) |
| :-: | :-: | :---: | :-------: |
|  0  |  0  |   0   |     0     |
|  0  |  1  |   1   |     1     |
|  1  |  0  |   1   |     1     |
|  1  |  1  |   0   |     0     |

Например, условие `(x > 0 && y < 10)` истинно только при `x>0` **и** `y<10`. Примеры кода:

```cpp
bool a = true, b = false;
std::cout << (a && b); // 0 (false)
std::cout << (!a);     // 0 (false)
```

В булевой алгебре часто используют те же таблицы: для конъюнкции «истина только если истинны оба», для дизъюнкции «истина если хотя бы один истинный». Таблицы истинности помогают визуально проверить все случаи работы логических функций.

# 20. Логические основы. Диаграммы. Преобразование и упрощение логических выражений. Логические уравнения.

**Логические основы** – это законы булевой алгебры, по которым преобразуются логические выражения. С помощью логических **диаграмм** (например, схем на основе логических вентилей) визуально представляют алгоритмы или функции. Упрощение логических выражений проводится с помощью тождеств булевой алгебры:

* **Основные законы**: ассоциативность, коммутативность, дистрибутивность;
* **Идемпотентность**: `A&&A = A`, `A||A = A`;
* **Нулевые и единичные элементы**: `A && false = false`, `A || true = true`, `A && true = A`, `A || false = A`;
* **Отрицание**: `!!A = A`, а также *законы де Моргана* `!(A && B) = !A || !B`, `!(A || B) = !A && !B`.

Например, выражение `(A && B) || (A && !B)` можно упростить вынесением `A`: `A && (B || !B)`, а так как `(B || !B)=true`, то это равно просто `A`. Вышло, что `(A && B) || (A && !B)` эквивалентно `A`.

Логические **уравнения** – это равенства, которые истинны при определённых комбинациях переменных. Решение логического уравнения означает найти все наборы переменных, при которых выражение равно `true`. Например, уравнение `(A && B) || C = true` означает, что либо `A && B` истинно, либо `C` истинно. Его решения – все комбинации, где выполняется это условие. Часто решают такие уравнения применяя законы булевой алгебры или строя таблицу истинности.

Для упрощения часто используют **карты Карно** или алгоритмы минимизации (Quine–McCluskey) – специальные техники минимизации булевых функций. Они позволяют систематически находить минимальный по числу членов или сумм формул вид. Также можно рисовать логические схемы (схемы с вентилями И, ИЛИ, НЕ) и упрощать их, объединяя входы или удаляя лишние гейты.

В итоге упрощение делает код и схему проще, быстрее и надёжнее. Преобразование производится по справочным закономерностям булевой алгебры (таким, как `A + A = A`, `A * 0 = 0`, законы де Моргана и т.д.). Таким образом, логическое выражение можно привести к компактному эквивалентному виду, что важно при проектировании схем и при оптимизации программного кода.

Хорошо. Я продолжу подробный разбор экзаменационных вопросов с 21 по 30, придерживаясь того же академического стиля: подробные пояснения, примеры на C++ (если применимо), таблицы, схемы и логические рассуждения.

Скоро представлю следующую часть шпаргалки.

## 21. Синтез логических выражений. Способы решения логических задач. Примеры.

**Синтез логического выражения** – построение логического (булева) выражения по заданной таблице истинности функции. Для каждой строки таблицы, где функция равна 1, составляют конъюнкцию (AND) переменных (или их отрицаний) так, чтобы она была истинна только в этой строке, а затем складывают (OR) эти конъюнкции. Полученная форма называется дизъюнктивной нормальной формой (ДНФ). Аналогично строят КНФ – берут строки с нулевым значением функции, составляют дизъюнкции (OR) переменных, обращая переменные, равные 1, и затем перемножают (AND) их. Другой подход – сначала найти выражение, описывающее нулевые случаи, а затем взять его отрицание (инверсию) как искомую функцию. Для упрощения конечного выражения применяют правила булевой алгебры или карты Карно.

*Пример (ДНФ):* пусть требуется функция от А и В, принимающая значение 1 только при (А=0, В=1) и (А=1, В=0). Для строк с единицей строим выражения: при (A=0,B=1) – «¬A && B», при (A=1,B=0) – «A && ¬B». Их дизъюнкция: `F = (!A && B) || (A && !B)`. Это – ДНФ, которую можно упростить, используя законы (в данном случае это эквивалентно `F = A XOR B`).

В программировании такие выражения реализуют логическими операторами C++ (`&&`, `||`, `!`). Например, для условия «A или не B» можно написать:

```cpp
bool f = A || (!B);
```

Для решения логических задач обычно составляют таблицу истинности, затем переходят к ДНФ или КНФ, и при необходимости упрощают выражение.

## 22. Битовые операции (сдвиги, побитовые И, ИЛИ, XOR).

**Побитовые операции** – операции, действующие над двоичным представлением целых чисел. Операции `&` (AND), `|` (OR), `^` (XOR) и `~` (NOT) применяются к каждому биту числа по правилам логических операций. Так, битwise-AND (`a & b`) даёт 1 в разряде, только если в обоих числах в этом разряде стоит 1. Bitwise-OR (`a | b`) равен 1, если хотя бы один бит равен 1. Побитовое XOR (`a ^ b`) равно 1, когда биты различны. Например, `5 & 3` (0101 & 0011) = 0001 (1), `5 | 3` = 0111 (7), `5 ^ 3` = 0110 (6).

**Побитовые сдвиги:** операции `<<` и `>>` сдвигают двоичное представление числа влево или вправо на указанное число позиций. При сдвиге влево (`a << k`) на освобождающиеся младшие биты ставятся нули, что эквивалентно умножению на 2<sup>k</sup>. При сдвиге вправо (`a >> k`) старшие биты заполняются нулями (для беззнакового типа) или знаковыми битами (для знакового типа), что эквивалентно целочисленному делению на 2<sup>k</sup> (с округлением вниз для положительных).

*Пример кода:*

```cpp
unsigned int x = 5; // 0101₂
unsigned int y = 3; // 0011₂
cout << (x & y) << " "; // 1   (0001₂)
cout << (x | y) << " "; // 7   (0111₂)
cout << (x ^ y) << " "; // 6   (0110₂)
cout << (x << 1) << " "; // 10  (1010₂)
cout << (y >> 1) << endl; // 1   (0001₂)
```

Таким образом, побитовые операции позволяют работать с флагами и битовыми масками эффективно, а сдвиги быстро умножают или делят число на 2**k**.

## 23. Алгоритмы сортировки массивов (метод сортировки обменами, вставками, выбором, «быстрая»).

**Сортировка обменами (пузырьком):** многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они стоят в неправильном порядке. При каждом проходе «всплывает» максимальный элемент в конец массива. Алгоритм прост, но неэффективен при больших данных. Сложность в худшем и среднем случаях – *O(n²)*.

```cpp
// Сортировка пузырьком (обменами)
for(int i = 0; i < n-1; i++){
    for(int j = 0; j < n-1-i; j++){
        if(a[j] > a[j+1]) std::swap(a[j], a[j+1]);
    }
}
```

**Сортировка вставками:** элементы последовательно берутся по одному и вставляются в уже отсортированную часть массива, сдвигая большие элементы вправо. Для каждого элемента ищется его место среди предыдущих. Хорошо работает на частично отсортированных данных. В лучшем случае (*массив уже отсортирован*) – *O(n)*, в среднем и худшем – *O(n²)*.

```cpp
// Сортировка вставками
for(int i = 1; i < n; i++){
    int key = a[i];
    int j = i - 1;
    while(j >= 0 && a[j] > key){
        a[j+1] = a[j];
        j--;
    }
    a[j+1] = key;
}
```

**Сортировка выбором:** на i-м шаге ищет минимальный элемент среди неотсортированной части и меняет его с элементом a\[i]. Делит массив на отсортированную и неотсортированную части. Сложность – *O(n²)* в любом случае.

```cpp
// Сортировка выбором
for(int i = 0; i < n-1; i++){
    int minIdx = i;
    for(int j = i+1; j < n; j++){
        if(a[j] < a[minIdx]) minIdx = j;
    }
    std::swap(a[i], a[minIdx]);
}
```

**Быстрая сортировка (QuickSort):** рекурсивный алгоритм «разделяй и властвуй». Выбирают опорный элемент (pivot), затем переставляют элементы так, что все меньшие идут влево, большие – вправо. После этого рекурсивно сортируют подмассивы слева и справа. В среднем работает за *O(n log n)*, но в худшем случае *O(n²)* (например, при плохом выборе опорного элемента).

```cpp
void quicksort(int a[], int l, int r){
    if(l < r){
        int pivot = a[(l+r)/2];
        int i = l, j = r;
        while(i <= j){
            while(a[i] < pivot) i++;
            while(a[j] > pivot) j--;
            if(i <= j) std::swap(a[i++], a[j--]);
        }
        quicksort(a, l, j);
        quicksort(a, i, r);
    }
}
```

Каждый алгоритм имеет свои применения: пузырёк и вставки – просты, но медленные на больших данных; выбор (selection) экономит запись (меняет местами меньше), но всё равно *O(n²)*. Быстрая сортировка обычно используется на практике благодаря быстрому среднему времени.

## 24. Алгоритмы сортировки (нахождение медианы, цифровая сортировка и др.).

**Нахождение медианы:** наивный способ – отсортировать массив и взять средний элемент (или среднее двух) – *O(n log n)*. Более эффективен алгоритм «quickselect» (разработка Хоара), который на среднем выполняется за *O(n)*. Quickselect рекурсивно разбивает массив по опорному элементу и выбирает нужную половину для поиска k-го по величине элемента (например, медианы). В C++ для поиска k-го элемента можно использовать `std::nth_element`, что обычно работает линейно. Например:

```cpp
vector<int> v = { ... };
int k = v.size()/2;
std::nth_element(v.begin(), v.begin()+k, v.end());
int median = v[k];
```

**Цифровая (поразрядная) сортировка:** алгоритм, использующий разряды ключей. Часто применяют LSD-сортировку: сначала устойчиво сортируют по младшему разряду (например, единицы), затем по следующему (десятки) и т.д., сохраняя порядок предыдущей сортировки. Аналогично есть MSD-сортировка (от старших разрядов вниз). Этот метод особенно эффективен для ключей фиксированной длины (числа, строки). Поразрядная сортировка выполняется примерно за *O(w·n)*, где *w* – число разрядов ключа; при фиксированной длине ключей это линейно от количества элементов. Например, сортировка десятеричных чисел по цифрам или строк посимвольно (разбиение на символы и последовательная сортировка подсчётом) позволяет получить линейную сложность.

**Другие нестандартные подходы:** существуют варианты сортировок, например, «медиана трёх» для выбора хорошего опорного элемента в quicksort (чтобы улучшить баланс), сортировка Шелла (Shell sort) со «шагами», пирамидальная (heap-sort) и др. Также «цифровая сортировка» может включать распространённую сортировку подсчётом (counting sort), используемую для одного разряда.

## 25. Прямое слияние. Естественное слияние.

**Сортировка прямым слиянием (fixed-run merge):** массив разбивается на упорядоченные участки (серии) одинаковой фиксированной длины (обычно начинающейся с 1, 2, 4… при многопроходном алгоритме), после чего пары таких серий сливаются попарно в большую отсортированную последовательность. Этот метод требует дополнительной памяти для слияния двух серий. Пример: классический рекурсивный merge sort делит массив пополам, сортирует каждую часть и потом объединяет (сливает) их.

**Естественное слияние:** вместо заранее заданных длин серий алгоритм ищет уже существующие отсортированные фрагменты массива («естественные серии»). При каждом проходе берутся две наибольшие найденные упорядоченные серии и сливаются. Так, длинные «раннеры» (предотсортированные куски) объединяются первыми. Преимущество: часто требуется меньше проходов по данным (количество чтений/записей сравнимо или лучше, чем у простого слияния), но нужно распознавать границы серий. Внешние файлы в методах внешней сортировки (например, при сортировке больших файлов) также используют прямое или естественное слияние.

*Пример функции слияния двух отсортированных массивов:*

```cpp
vector<int> mergeSeries(const vector<int>& A, const vector<int>& B) {
    vector<int> C;
    int i = 0, j = 0;
    while(i < A.size() && j < B.size()){
        if(A[i] < B[j]) C.push_back(A[i++]);
        else C.push_back(B[j++]);
    }
    while(i < A.size()) C.push_back(A[i++]);
    while(j < B.size()) C.push_back(B[j++]);
    return C;
}
```

Эта функция объединяет два упорядоченных фрагмента в один отсортированный массив.

## 26. Алгоритмы поиска.

**Линейный поиск:** самый простой алгоритм поиска. Просматривает массив поэлементно (слева направо) и сравнивает каждый элемент с ключом. Не требует предварительной сортировки или дополнительной структуры данных. Сложность – *O(n)*.

```cpp
int linearSearch(const vector<int>& a, int key) {
    for(int i = 0; i < a.size(); i++){
        if(a[i] == key) return i;
    }
    return -1; // не найден
}
```

**Двоичный (бинарный) поиск:** эффективен на **отсортированном** массиве. На каждом шаге сравнивает ключ с серединным элементом: если ключ меньше – ищет в левой половине, иначе – в правой. Так диапазон поиска сокращается вдвое. Средняя и худшая сложность – *O(log n)*. Требует, чтобы массив был предварительно отсортирован.

```cpp
int binarySearch(const vector<int>& a, int key) {
    int left = 0, right = a.size() - 1;
    while(left <= right){
        int mid = left + (right - left) / 2;
        if(a[mid] == key) return mid;
        else if(a[mid] < key) left = mid + 1;
        else right = mid - 1;
    }
    return -1; // не найден
}
```

Кроме них существуют и другие поисковые алгоритмы: **интерполяционный поиск** (для равномерно распределённых данных \~O(log log n)), **экспоненциальный поиск**, а также методы поиска в графах (BFS, DFS), поисковые алгоритмы в деревьях (поиск ключа в БД) и т.д. В STL C++ также есть функции `std::find`, `std::binary_search`, `std::lower_bound` для реализации поиска.

## 27. Принцип работы поисковых машин. Роботы. Назначение различных роботов.

**Принцип работы поисковой системы:** состоит из трёх этапов: (1) **Сбор (краулинг):** специальные программы («веб-краулеры» или «пауки») обыскивают Интернет по ссылкам, собирая содержимое страниц. Пауки проходят по URL, загружают страницы, анализируют текст и переходят по встреченным ссылкам. (2) **Индексирование:** полученные страницы разбираются, выделяются ключевые слова и метаданные, создаётся огромная база (поисковый индекс), позволяющая быстро находить документы по запросу. (3) **Ранжирование и выдача:** при вводе запроса система ищет в индексе релевантные документы и упорядочивает их согласно алгоритмам ранжирования.

**Поисковые роботы (краулеры):** это программы, часть поисковой системы, которые **сканируют** страницы и передают информацию в индекс. Они похожи на браузер: загружают страницу, анализируют содержимое и следуют по ссылкам. У каждого поискового сервиса обычно свои роботы. Например, у Google – Googlebot, у Яндекса – YandexBot, у Bing – Bingbot. **Googlebot** – основной робот Google, соблюдающий правила сайта (robots.txt) и ограничивающий скорость сканирования. Есть и **специальные роботы**: например, AdsBot Google проверяет корректность рекламных страниц и может игнорировать обобщённое правило `User-agent: *`, если сайт явно разрешил рекламу. **Пользовательские загрузчики:** например, инструменты типа Google Site Verifier, запускаются вручную и позволяют владельцу сайта вызвать сканирование или проверить настройки. Кроме того, существуют «дятлы» – роботы-мониторы, которые периодически проверяют доступность уже проиндексированных страниц.

С помощью файла `robots.txt` владельцы сайтов могут ограничивать поведение роботов (например, указывать, какие разделы не сканировать). Поисковые машины также учитывают различные факторы (частоту обновления контента, ссылки на сайт, скорость загрузки и др.) при оценке важных страниц.

## 28. Принципы создания интерфейсов ПО. Основные факторы и принципы. Использование цвета. Тексты, диалоги, иконки.

**Основные принципы UI/UX:** интерфейс должен быть простым и понятным. Избегайте перегрузки экрана элементами – фокусируйтесь на ключевых задачах пользователя. Оставляйте достаточно свободного пространства вокруг элементов (принцип «минимализма» и whitespace). **Согласованность:** одинаковые действия должны выглядеть и работать одинаково во всём приложении. **Естественность:** используйте привычные метафоры (корзина для удаления, дискета для сохранения и т.д.) и понятный язык.

**Цветовая палитра:** не должна быть слишком яркой или хаотичной. Рекомендуется сочетание нейтральных фонов с яркими акцентами на важных элементах (кнопки, ошибки, выделения). Цвета должны передавать смысл (например, зелёный – успех, красный – ошибка) и не раздражать пользователя. **Текст:** используйте четкие читаемые шрифты и достаточный размер. Избегайте мелкого или «декоративного» шрифта, чтобы текст легко читался на любых устройствах. Тексты подсказок и сообщений должны быть краткими, информативными и без жаргона.

**Диалоги и сообщения:** диалоговые окна (alert, confirm) и всплывающие подсказки должны быть краткими и содержательными. Сообщение диалога должно чётко сообщать пользователю, что произошло и какие есть варианты действий. Кнопки в диалогах следует подписывать однозначно (например, «Удалить» или «Отменить»), а не «Да/Нет», чтобы не вызывать двусмысленности.

**Иконки:** должны быть простыми и интуитивно понятными. Иконки выполняют роль визуальных сокращений текста – используйте знакомые символы (лупа для поиска, карандаш для редактирования) и сопровождайте их при необходимости поясняющим текстом (tooltip или подписью). Иконки одного типа (например, действий) должны быть стилистически схожими по цвету и форме, чтобы сохранять единый стиль.

## 29. Принципы создания интерфейсов ПО. Принципы проектирования меню. Формы. Навигация. Проектирование сообщений. Обработка ошибок.

**Меню и навигация:** структура меню должна быть логичной и предсказуемой. Пользователь всегда должен понимать, где он находится. Например, в процессе оформления чего-либо интерфейс должен обозначать текущий шаг или контекст («Оформление кредита» при заполнении кредитной заявки). Элементы меню размещают там, где пользователь ожидает их найти (например, главное меню – вверху или слева). Подменю не должны быть избыточными; лучше разделять функции по логическим разделам. Поход по меню должен вести к основной задаче; лишние клики снижает удобство.

**Формы ввода:** метки полей должны быть над или слева от полей ввода, чтобы пользователю было ясно, что куда вводить. Обязательные поля обычно отмечают «звёздочкой» и предупреждают о пустых полях. Проверку ввода (валидацию) лучше делать интерактивно – сразу после заполнения поля, но так, чтобы сообщение не «дёргало» пользователя (не вызывайте ошибку при потере фокуса, если пользователь ещё заполняет форму).

**Навигация:** всегда предлагайте пользователю возможность вернуться назад или отменить действие. Для длинных последовательностей действий (например, покупка) используют «хлебные крошки» или шаги прогресса. Добавляйте поиск по содержимому, если элементов много. Главное меню и часто используемые действия должны быть легко доступны, остальное – спрятано в менее заметные разделы.

**Сообщения и обработка ошибок:** при успешном действии (успех, предупреждение, информация) или возникновении ошибки система должна показывать уведомление. Сообщения **об ошибках** должны быть заметными (обычно красным цветом), объяснять что пошло не так и как это исправить. Например, если ввод неверен, выведите: «Поле ‘Email’ заполнено неправильно, введите корректный адрес» (вместо «Ошибка ввода»). Показывайте сообщения об ошибке рядом с соответствующими полями формы. Избегайте пугающих системных текстов («NullPointerException» и т.п.) – вместо этого пишите дружелюбно и по-человечески.

*Пример:* если в форме обязательное поле осталось пустым, сообщение «Пожалуйста, заполните это поле» должно появиться после попытки отправки формы, а не на каждый фокус, чтобы пользователь не раздражался. Сообщения об ошибках должны удовлетворять правилам: они узнаваемы (цветом), понятны по содержанию, контекстны и неназойливы.

## 30. Принципы создания интерфейсов ПО. Справочная система, понятийность, оптимизация работы пользователя.

**Справочная система:** интерфейс должен предоставлять пользователю возможность получить помощь. Это может быть контекстная справка (кнопка «?»), вкладка «Помощь» или онлайн-документация. Полезно включить FAQ, советы и пошаговые руководства для частых операций. Даже если интерфейс интуитивен, помощь никогда не помешает: короткие инструкции и подсказки делают программу дружелюбнее и помогают новым пользователям быстрее освоиться.

**Понятийная согласованность:** используйте в интерфейсе единый терминологический аппарат и метафоры. То, как организованы данные и действия в программе, должно соответствовать логической модели пользователя (ментальной модели). Например, если в бухгалтерской программе «документ продажи» называется «Счет», везде используйте одно слово, чтобы избежать путаницы. Концепции и процессы должны отражаться в терминологии интерфейса, а новое название вводиться только при необходимости.

**Оптимизация работы пользователя:** минимизируйте усилия пользователя. Предоставляйте умолчания и автозаполнение, чтобы не вводить повторно одни и те же данные. Используйте сочетания клавиш и быстрые команды для опытных пользователей. Запоминайте шаблоны и настройки пользователя (например, последний каталог для сохранения файла). Сокращайте число действий: например, после сохранения документа автоматически возвращаться в редактирование, не заставляя пользователя вручную закрывать окно. Всегда показывайте пользователю обратную связь о статусе операции (загрузка, сохранение) и старайтесь выполнить тяжёлые операции фоном, чтобы интерфейс оставался отзывчивым.

В итоге интерфейс должен помогать пользователю решать его задачи без лишних препятствий: чёткая справка, понятные термины и эффективные механизмы ускоряют работу и делают программу удобной в использовании. Источник рекомендаций для сообщений об ошибках и помощи – эвристики Нильсена.

Хорошо, продолжаю разбор вопросов 31–40 в том же стиле — с подробными объяснениями, примерами на C++, таблицами и схемами, где это необходимо.


# Разбор вопросов

## 31. Графы. Основные понятия и определения для ориентированных графов

* **Ориентированный граф (орграф)** – это граф, в котором каждому ребру (дуге) задано направление. Формально ориентированный граф $D=(V,E)$ состоит из множества вершин $V$ и множества упорядоченных пар вершин $E\subseteq V\times V$, называемых дугами. Дуга $(u,v)$ инцидентна вершинам $u$ (начало) и $v$ (конец).
* **Степени вершины**. У ориентированного графа для каждой вершины определены степень **исхода** (количество дуг, исходящих из вершины) и степень **захода** (количество дуг, входящих в вершину).
* **Маршрут (путь)** – это последовательность вершин и дуг $(v_0, \{v_0,v_1\}, v_1, \ldots, v_n)$, соединяющая начальную вершину $v_0$ с конечной $v_n$. Простой путь не повторяет вершины. Если начальная и конечная вершина совпадают, путь называется **контуром (циклом)**.
* **Связность**. Орграф называется **сильно связным**, если для любой пары вершин $u$ и $v$ существует путь из $u$ в $v$ и из $v$ в $u$ (с учётом направлений). **Слабо связный** орграф – это тот, который становится связным, если игнорировать направления ребер.
* **Пример применения.** Ориентированные графы моделируют односторонние отношения: например, денежные переводы между людьми (каждое ребро указывает направление перевода), или маршрутизацию пакетов в сети (направленные соединения).

## 32. Графы. Основные понятия и определения для неориентированных графов

* **Неориентированный граф** – это граф, ребра которого не имеют направления. Формально $G=(V,E)$, где $V$ – вершины, а $E$ – множество неупорядоченных пар вершин $\{u,v\}$. Ребро $\{u,v\}$ связывает вершины $u$ и $v$ симметрично: при наличии связи между $u$ и $v$ и $v$ и $u$ взаимно связаны.
* **Степень вершины** – количество инцидентных ей ребер. Для неориентированного графа степень вершины $v$ равна числу ребер, идущих из $v$ (петли учитываются дважды).
* **Связность**. Неориентированный граф называется **связным**, если любая вершина достижима из любой другой. Компонента связности – максимальное множество вершин, соединенных путями.
* **Пути и циклы**. Путь в неориентированном графе – последовательность вершин, связанных ребрами. Цикл – замкнутый путь. В неориентированном дереве (см. вопрос 34) любой путь между двумя вершинами единственен.
* **Применение.** Неориентированные графы удобны для моделирования взаимоотношений типа «дружба» или «связь», где отношение симметрично (например, граф дорог между городами). Они часто используются в алгоритмах поиска компонент, минимальных остовных деревьев и т.д.

## 33. Способы представления графов

* **Матрица смежности.** Граф на $N$ вершинах задаётся квадратной матрицей $N\times N$, где элемент $A[i][j]$ = `true` (или вес) означает наличие ребра (или дуги) из вершины $i$ в $j$. Для неориентированного графа матрица симметрична ($A[i][j]=A[j][i]$). Преимущества: быстрое (за $O(1)$) определение наличия ребра. Недостаток: память $O(N^2)$, неэффективно для разреженных графов.

  ```cpp
  int N;
  // Матрица смежности (логическая или весовая)
  vector<vector<bool>> adj(N, vector<bool>(N, false));
  // Чтение рёбер (для неориентированного графа устанавливаем обе симметричные позиции):
  for(int e=0;e<m;e++){
      int u,v; cin>>u>>v;
      adj[u][v] = true;
      adj[v][u] = true;  // убрать для ориентированного графа
  }
  // Проверка наличия ребра (i->j)
  if(adj[i][j]) { ... }
  ```
* **Список смежности.** Каждой вершине $v$ соответствует список (вектор) её соседей – вершин, смежных $v$ ребром. Для хранения используется, например, `vector<vector<int>> adj;`, где `adj[v]` – список вершин, смежных с `v`. Преимущества: экономно по памяти $O(|V|+|E|)$, хорошо для разреженных графов. Проверка наличия конкретного ребра требует перебора соседей (время $O(\deg(v))$).

  ```cpp
  int N;
  vector<vector<int>> adj(N);
  // Чтение рёбер:
  for(int e=0;e<m;e++){
      int u,v; cin>>u>>v;
      adj[u].push_back(v);
      adj[v].push_back(u);  // убрать для ориентированного графа
  }
  // Перебор соседей вершины i:
  for(int neigh : adj[i]) {
      // обработка смежной вершины neigh
  }
  ```
* **Список рёбер (перечень пар).** Достаточно просто хранить список всех рёбер или дуг (пары индексов вершин). Удобно для алгоритмов, где перебираются именно рёбра (например, при построении мин. остова или применении алгоритма Краскала).
* **Резюме**: Матрица смежности подходит для плотных графов (быстрый доступ к ребрам, но требует $O(N^2)$ памяти). Список смежности эффективен для разреженных графов (память $O(N+E)$).

## 34. Деревья. Виды, основные понятия, примеры использования

* **Определение дерева**: дерево – это **связный ациклический неориентированный граф**. Связность означает, что существует путь между любыми двумя вершинами; ацикличность – отсутствие циклов. Следствия: в дереве на $n$ вершинах ровно $n-1$ ребро; между любой парой вершин существует единственный простой путь.
* **Корневое (ориентированное) дерево**: ориентированный ациклический граф, в котором есть один специальный узел – **корень** (индегрейтинг 0, из него исходят дуги), все остальные вершины имеют ровно один входящий ребро. В ориентированном дереве вершины без исходящих дуг называют листьями (концевые вершины).
* **Виды деревьев**:

  * *Бинарное дерево*: каждый узел имеет не более двух потомков (линейный двоичный список на уровне графа), причём в представлении можно говорить о левом и правом ребенке. В информатике бинарное дерево – ключевая структура: на них основаны **двоичное дерево поиска**, **бинарная куча**, **красно-чёрное дерево**, **АВЛ-дерево** и др..
  * *N-арное дерево*: обобщение бинарного, где каждый узел имеет не более N потомков.
  * *Лес*: множество деревьев (несвязный граф без циклов).
* **Основные понятия**: корень дерева, лист (листовой узел, степень 1), внутренние узлы; глубина/уровень узла (расстояние до корня), высота дерева (максимальная глубина); степень (число потомков узла). Любое ребро дерева – мост (разбиение приводит к двум компонентам).
* **Применение**: деревья широко используются для иерархических и переборных структур:

  * Файловая система – древовидная структура каталогов (иерархия папок).
  * Классификационные деревья (таксономии) и др. иерархии (например, биологическая систематика).
  * Парсинг выражений: арифметическое выражение отображается в виде бинарного дерева (листья – числа и переменные, внутренние узлы – операции).
  * Алгоритмы поиска: в графе BFS/DFS строятся древовидные структуры (деревья обхода).
  * Двоичное дерево поиска (BST) обеспечивает быструю сортировку, поиск, вставку за логарифмическое время (в среднем).
  * Пирамидальная сортировка и поиск оптимального элемента используют **бинарные кучи**.
  * В базах данных и файловых системах применяются B-деревья, B+-деревья – сбалансированные многаренные деревья для индексации и эффективного доступа.
  * Сети и организации (например, оргструктуры компаний) часто представляются в виде дерева.
* **Свойства**: любое дерево является двудольным и планарным графом.

## 35. Деревья. Реализация программными методами

* **Двоичное дерево (пример)**. Каждый узел (Node) содержит данные и ссылки на потомков. Например:

  ```cpp
  struct Node {
      int data;
      Node* left;   // указатель на левое поддерево
      Node* right;  // указатель на правое поддерево
      Node(int v) : data(v), left(nullptr), right(nullptr) {}
  };
  ```

  Создадим простой древовидный набор:

  ```cpp
  // Создание корневого узла и его детей
  Node* root = new Node(10);
  root->left = new Node(5);
  root->right = new Node(15);
  root->left->left = new Node(3);
  root->left->right = new Node(7);
  ```
* **Обход дерева (рекурсивный)**. Часто реализуют три основных обхода: прямой (pre-order), симметричный (in-order), обратный (post-order). Например, прямой обход:

  ```cpp
  void preorder(Node* node) {
      if(!node) return;
      cout << node->data << " ";
      preorder(node->left);
      preorder(node->right);
  }
  // Использование:
  preorder(root);
  ```

  При **симметричном** обходе порядок: `left, root, right`, при **обратном**: `left, right, root`.
* **Другие реализации**: деревья можно хранить и иначе. Например, полузаконченный массив (heap) для бинарной кучи: элемент в массиве, детей узла с индексом i имеют индексы 2*i+1 и 2*i+2. Или **N-арные деревья**, где у узла хранится массив указателей на N детей.
* **Использование STL**. В C++ нет стандартной библиотеки специально для двоичных деревьев, но контейнеры `std::set`, `std::map` обычно реализованы как сбалансированные двоичные деревья (красно-чёрные). `std::priority_queue` (очередь с приоритетом) основана на бинарной куче. Для общего бинарного дерева придётся писать собственную структуру (как показано выше) или использовать умные указатели.

## 36. Стек. Операции. Реализация программными методами

* **Определение стека**: стек – это абстрактный тип данных, в котором элементы добавляются и удаляются по принципу **LIFO** (Last In, First Out – «последним пришёл – первым вышел»).
* **Операции**:

  * `push(x)` – положить элемент `x` на вершину стека.
  * `pop()` – удалить элемент с вершины и вернуть его.
  * `top()` или `peek()` – получить значение верхнего элемента без удаления.
  * `empty()` – проверить, пуст ли стек.
  * `size()` – получить число элементов.
* **Пример реализации**: стек часто реализуют поверх динамического массива (или `std::vector`) или односвязного списка. Простейший пример на массиве:

  ```cpp
  struct Stack {
      vector<int> elems;
      void push(int x) { elems.push_back(x); }
      int pop() { 
          int x = elems.back(); elems.pop_back(); 
          return x;
      }
      int top() const { return elems.back(); }
      bool empty() const { return elems.empty(); }
  };
  // Использование:
  Stack st;
  st.push(1);
  st.push(2);
  int a = st.pop();  // a = 2
  bool isEmpty = st.empty();
  ```

  Можно также использовать контейнер `std::stack<int> st;` из стандартной библиотеки (он обычно основан на векторе или deque).

## 37. Дек (двусторонняя очередь). Операции. Реализация программными методами

* **Двусторонняя очередь (дек)** – это структура данных, расширяющая очередь, в которой элементы могут добавляться и удаляться **как с переднего (head), так и с заднего (tail) конца**. Часто дек обозначается как `deque` (double-ended queue).
* **Операции**:

  * `push_front(x)`, `pop_front()` – добавить/удалить элемент в/из начала деки.
  * `push_back(x)`, `pop_back()` – добавить/удалить элемент в/из конца деки.
  * `front()` – получить элемент из начала (без удаления), `back()` – из конца.
  * `empty()`, `size()` – проверки состояния.
* **Реализация**: дек удобно хранить как двусвязный список узлов или как кольцевой буфер. В C++ есть готовенный контейнер `std::deque<T>`, который эффективно реализует эти операции (обычно как динамический массив блоков).

  ```cpp
  #include <deque>
  std::deque<int> dq;
  dq.push_back(10);
  dq.push_front(20);
  int first = dq.front();  // 20
  int last = dq.back();    // 10
  dq.pop_back();  // удалит 10
  dq.pop_front(); // удалит 20
  ```

## 38. Очередь. Операции. Реализация программными методами

* **Очередь (queue)** – это структура данных, работающая по принципу **FIFO** (First In, First Out – «первым пришёл – первым вышел»). Элементы вставляются в **хвост** очереди, а извлекаются из **головы**.
* **Операции**:

  * `push(x)` или `enqueue(x)` – вставить элемент `x` в хвост очереди.
  * `pop()` или `dequeue()` – удалить элемент из головы и вернуть его.
  * `front()` – получить (не удалять) элемент в голове очереди.
  * `empty()`, `size()` – проверка на пустоту и размер.
* **Реализация**: очередь удобно хранить в виде кольцевого (циклического) массива или односвязного списка с указателями на голову и хвост. В C++ стандартная очередь `std::queue<T>` реализована, например, на основе `deque` или списка. Пример:

  ```cpp
  #include <queue>
  std::queue<int> q;
  q.push(1);
  q.push(2);
  int x = q.front(); // 1
  q.pop();           // теперь 1 удалено
  bool isEmpty = q.empty();
  ```

  Можно также вручную делать кольцевой буфер:

  ```cpp
  const int MAXN = 100;
  int arr[MAXN];
  int head = 0, tail = 0; // головa и хвост
  void enqueue(int x) {
      arr[tail] = x;
      tail = (tail + 1) % MAXN;
  }
  int dequeue() {
      int res = arr[head];
      head = (head + 1) % MAXN;
      return res;
  }
  bool empty() { return head == tail; }
  ```

## 39. Списки. Реализация программными методами

* **Связный список** – базовая динамическая структура, состоящая из узлов, каждый из которых хранит данные и ссылки на следующий (и/или предыдущий) узел. В простейшем случае это **односвязный список** (каждый узел знает только о следующем узле). Преимущество перед массивом – гибкая динамическая структура: порядок элементов задаётся ссылками, а не расположением в памяти.
* **Виды списков**:

  * *Односвязный список* – узел хранит поле `next`, указывающее на следующий элемент; последний узел имеет `next = nullptr`.
  * *Двусвязный список* – в узле есть `next` и `prev` (ссылка на предыдущий). Удобен для двунаправленного обхода и удаления элемента без доступа к предыдущему элементу.
  * *Кольцевой список* – списку добавлена цикличность: у последнего элемента `next` указывает на голову списка. Может быть одно- или двусвязным.
* **Операции**: вставка/удаление в начало (операция `push_front`), вставка в конец, поиск, удаление элемента по значению, итеративный обход списка. Простейший пример (односвязный список):

  ```cpp
  struct Node {
      int data;
      Node* next;
      Node(int v) : data(v), next(nullptr) {}
  };

  Node* head = new Node(1);
  head->next = new Node(2);
  head->next->next = new Node(3);
  // Обход:
  for(Node* cur = head; cur != nullptr; cur = cur->next) {
      cout << cur->data << " ";
  }
  // Вставка в начало:
  Node* newNode = new Node(0);
  newNode->next = head;
  head = newNode;
  ```
* **Стандартная библиотека**: C++ предлагает `std::list<T>` – двусвязный список. Он обеспечивает вставку/удаление на любых позициях за константное время (известен только итератор на место). Но часто собственная реализация нужна для учебных задач.

## 40. Кодирование информации. Основные понятия. Построение кодов переменной длины. Пример

* **Определение кодирования**: кодирование информации – это отображение исходных данных на кодовые слова (строки символов из некоторого алфавита), согласно таблице соответствия. Цель – удобно представить информацию для хранения, передачи или обработки. Код $c: U \to Z^*$ – функция, отображающая символы из исходного множества $U$ в строки (кодовые слова) из алфавита $Z$.
* **Код фиксированной длины**: каждому символу исходного алфавита ставится в соответствие код одинаковой длины (обычно двоичной). Пример – ASCII (7 или 8 бит на символ). Такое кодирование называется *блочным кодом*.
* **Код переменной длины**: символам присваиваются кодовые слова разной длины. Часто символам с большей частотой использования дают более короткие коды, а редким – длинные.
* **Префиксный код**: специальный вид кода переменной длины, в котором **ни одно кодовое слово не является началом другого**. Это гарантирует однозначную декодируемость (не требуется разделитель между кодовыми словами). Пример префиксного кода – код Хаффмана. Все префиксные коды являются однозначно декодируемыми.
* **Алгоритм Хаффмана** – жадный алгоритм построения оптимального префиксного кода по заданным частотам (вероятностям) символов. Идея: объединять два наименее вероятных символа (узла) и строить бинарное дерево, где наиболее вероятные символы получат меньшую глубину (короткие коды). Коды Хаффмана обладают свойством префиксности и минимизируют суммарную длину закодированного сообщения при заданных частотах.
* **Пример кода переменной длины**: пусть есть 6 символов с частотами (или весами):

  ```
  Символ: A  B  C   D   E   F
  Частота: 5, 9, 12, 13, 16, 45
  ```

  По Хаффману может получиться следующий префиксный код (более частые – короче):

  |                                                                                                        Символ                                                                                                        | Частота | Код Хаффмана |
  | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: | :-----: | :----------: |
  |                                                                                                           F                                                                                                          |    45   |       0      |
  |                                                                                                           C                                                                                                          |    12   |      100     |
  |                                                                                                           D                                                                                                          |    13   |      101     |
  |                                                                                                           E                                                                                                          |    16   |      110     |
  |                                                                                                           A                                                                                                          |    5    |     1110     |
  |                                                                                                           B                                                                                                          |    9    |     1111     |
  | Такой код обладает свойством префиксности: например, код `0` для **F** не является началом ни одного другого кода. При декодировании мы можем поочерёдно читать битовые строки: `0` → F, `100` → C, `101` → D и т.д. |         |              |
* **Преимущества**: коды переменной длины (особенно оптимальные префиксные) обеспечивают более эффективное сжатие по сравнению с фиксированными кодами, если символы встречаются с разной частотой. Например, в сообщении из вышеприведённых символов средняя длина кода минимальна.
* **Итог**: при кодировании информации важно составлять таблицу соответствия (кодовую книгу) и обеспечивать однозначность декодирования; префиксные переменные коды (Хаффман и др.) являются одним из основных методов для эффективного кодирования данных.

Отлично, продолжаю в том же стиле: развернутые пояснения, примеры на C++, таблицы и схемы, где необходимо — для вопросов с 41 по 50.


# Экзаменационные вопросы 41–50 (информатика и программирование, C++)

## 41. Арифметическое кодирование

**Арифметическое кодирование** – метод без­потерянного сжатия, в котором последовательность символов кодируется единственным дробным числом (или интервалом) на отрезке \[0,1). Идея в том, что при каждом новом символе текущий интервал \[low, high) разбивается на части по вероятностям символов, и выбирается подынтервал для текущего символа. В результате в конце формируется узкий интервал, и любой кодовый фрагмент из него (например, середина) однозначно восстанавливает исходную последовательность. Это более эффективный подход, чем простое замена символов фиксированным кодом (как в Хаффмане), когда частоты меняются динамически.

* **Понятия:** используются вероятности символов, на основе которых строятся кумулятивные интервалы. Алгоритм поддерживает текущий \[нижний, верхний] границы (low, high). Для каждого символа S с диапазоном вероятности \[p(S), p(S)+P] вычисляется новый диапазон:

  ```
  newHigh = low + range * (p(S) + P);
  newLow  = low + range * p(S);
  range = oldHigh - oldLow;
  ```

  Затем low=newLow, high=newHigh, и так до конца сообщения.
* **Плюс:** обычно достигает более высокого сжатия, чем классический код типа Хаффмана, особенно для дробных вероятностей.
* **Минус:** чувствителен к точности арифметики и требует больше вычислений.

**Пример:** пусть алфавит {A,B,C} с вероятностями P(A)=0.6, P(B)=0.2, P(C)=0.2 (кумулятивные интервалы A:\[0,0.6), B:\[0.6,0.8), C:\[0.8,1.0)). Сжимаем строку «ABA»:

1. Начальный интервал \[0,1). Символ A: новый интервал \[0+1\*(0), 0+1\*0.6) = \[0.0, 0.6).
2. Символ B: \[low,high)=\[0,0.6), значение range=0.6. Интервал B:\[0.6,0.8) в исходной шкале. Новый:
   newLow = 0 + 0.6*0.6 = 0.36, newHigh = 0 + 0.6*0.8 = 0.48 → \[0.36,0.48).
3. Символ A: теперь \[low,high)=\[0.36,0.48), range=0.12. Интервал A:\[0,0.6) в исходной.
   newLow = 0.36 + 0.12*0 = 0.36, newHigh = 0.36 + 0.12*0.6 = 0.432 → \[0.36,0.432).

Полученный кодовый интервал – \[0.36,0.432). Для окончательного кода можно взять, например, 0.39. Такой код позволяет однозначно восстановить последовательность «ABA».

```cpp
#include <iostream>
#include <map>
#include <string>
using namespace std;
// Демонстрация арифметического кодирования интервалов
int main() {
    // Задаём вероятности (кумулятивные диапазоны) для символов
    map<string, pair<double,double>> probs;
    probs["A"] = {0.0, 0.6};
    probs["B"] = {0.6, 0.8};
    probs["C"] = {0.8, 1.0};
    vector<string> message = {"A","B","A"};
    double low = 0.0, high = 1.0;
    cout << "Начальный интервал: [" << low << ", " << high << ")" << endl;
    for (auto &sym : message) {
        double range = high - low;
        auto [p_low, p_high] = probs[sym];
        double newLow = low + range * p_low;
        double newHigh = low + range * p_high;
        cout << "Символ " << sym << " → новый интервал: ["
             << newLow << ", " << newHigh << ")" << endl;
        low = newLow; high = newHigh;
    }
    cout << "Финальный кодовый интервал: [" << low << ", " << high << ")" << endl;
    return 0;
}
```



## 42. Словарные методы кодирования

**Словарные методы** не требуют заранее известных статистик, а при сжатии динамически строят словарь повторяющихся фрагментов входных данных. Например:

* **LZ77 (слайдинг-окно):** при потоке данных поддерживается «окно» последних символов (слов), ищутся повторяющиеся подстроки в этом окне, и если найдено совпадение, вместо дублируемого фрагмента кодируется ссылка (смещение, длина) на это место. Пример: строка `pabcdeqpabcdeq`: фрагмент `abcde` во второй половине заменяется ссылкой на первый `abcde`: `pabcdeq<6,5>q`.
* **LZ78:** строится дерево (словарь) уникальных префиксных строк. При чтении поток разбивается так: на каждом шаге берём самую длинную строку, уже лежащую в словаре, и один дополнительный символ. Код записывается как `(номер_слова, новый_символ)` и добавляет новую строку в словарь.
* **LZW (Lempel–Ziv–Welch):** модификация LZ78, в которой словарь и коды строятся только на приёме, и код `префикс+символ` сразу отдаётся, без явной передачи символа. Начальный словарь содержит все символы алфавита. Например, при сжатии «ABABABA» алгоритм выдаёт коды `[0,1,2,4]` (в 0–1-индексации), где создаются новые словарные коды для строк «AB», «BA», «ABA» и т.д.

Основные особенности словарных методов:

* **Построение словаря:** при обработке входа словарь расширяется динамически повторяющимися фрагментами.
* **Кодирование:** вместо символа передаётся ссылка на словарь (номер или ссылку на позицию и длину).
* **Применение:** широко используют форматы GIF (LZW), ZIP/GZIP (LZ77-подобные), PNG (LZ77 в комбинации с Huffman).

**Пример (LZW):** Пусть исходная строка `S = "ABABABA"`. Начальный словарь: A=0, B=1.

1. Берём `A`, код 0, в словарь добавляем «AB»=2.
2. Берём `B`, код 1, добавляем «BA»=3.
3. Следующее два символа «AB» уже есть (код 2), дописываем `A` → «ABA» не в словаре. Выводим код 2, добавляем «ABA»=4.
4. Последний символ `A` код 0.
   Вывод кодов: `[0,1,2,0]` или `[0,1,2,4]` (зависит от реализации, приведена общая идея).



## 43. Дифференциальное кодирование. Сжатие способом кодирования серий

**Дифференциальное кодирование (delta-кодирование)** – техника, где вместо абсолютных значений передаются разности между соседними отсчётами (данными). Это эффективно, если данные меняются плавно: разности обычно меньше по величине и более «скучены» (менее энтропичны), что даёт лучшее сжатие. Пример: массив `A = {100, 103, 105, 107}` можно закодировать как `{100, +3, +2, +2}`. На языке C++ вычисление дельта-значений:

```cpp
vector<int> A = {100, 103, 105, 107};
vector<int> diff;
diff.push_back(A[0]);
for(int i = 1; i < A.size(); i++){
    diff.push_back(A[i] - A[i-1]);
}
// diff = {100, 3, 2, 2}
```

При декодировании просто восстанавливаем накоплением.

**Кодирование серий (RLE – Run-Length Encoding)** – базовый метод без­потеря­ного сжатия, заменяющий серии одинаковых символов («ранг») на пару «количество+символ».

* Пример: строку `AAAABBBCC` можно закодировать как `4A3B2C`.
* Подходит для данных с частыми длинными сериями (например, одноцветное изображение из битов или символов).
* На C++ пример реализации RLE:

  ```cpp
  string s = "AAAABBBCCDAA";
  vector<pair<char,int>> rle;
  char curr = s[0]; int count = 1;
  for(int i = 1; i < s.size(); i++){
      if(s[i] == curr) count++;
      else {
          rle.push_back({curr, count});
          curr = s[i];
          count = 1;
      }
  }
  rle.push_back({curr, count});
  // Вывод результата
  for(auto &p : rle){
      cout << p.second << p.first;
  }
  // Вывод: 4A3B2C1D2A
  ```
* **Преимущество:** простота, эффективен для данных с «плоскими» фрагментами. Недостаток – плохая эффективность при случайных данных без длинных повторов.



## 44. Алгоритм Дейкстры

**Алгоритм Дейкстры** – классический жадный алгоритм поиска кратчайших путей от заданной вершины-источника до всех остальных вершин взвешенного графа с **неотрицательными весами ребер**. Он гарантирует нахождение минимальных расстояний при условии неотрицательности весов. Шаги алгоритма:

* Инициализируем для каждой вершины `dist[v] = ∞`, кроме стартовой `dist[src] = 0`. Множество `S` пройденных вершин пусто.
* **Основной цикл:** пока есть вершины вне `S`:

  1. Выбрать из непомеченных вершину `u` с минимальным `dist[u]`. Пометить `u` как посещённую (добавить в S).
  2. Для каждого ребра `(u,v)` проверить, можно ли улучшить путь: если `dist[v] > dist[u] + w(u,v)`, то обновить `dist[v] = dist[u] + w(u,v)` (релаксация).
* После окончания в `dist[]` будут храниться длины кратчайших путей от `src` до всех вершин (либо ∞, если достижимость отсутствует).

*Рисунок:* пример шагов алгоритма Дейкстры. На каждом шаге множество окончательно найденных вершин `S` (синие) расширяется вершиной с минимальным приоритетом, а через её рёбра обновляются расстояния до соседей.

Алгоритм обычно реализуют с помощью приоритетной очереди (например, `std::priority_queue`), что даёт сложность примерно \$O((N+M)\log N)\$ (где \$N\$ – число вершин, \$M\$ – число рёбер). В чистом виде без очереди (нахождение минимума линейным поиском) сложность \$O(N^2)\$.

**Пример кода (C++):** классическая реализация Дейкстры с помощью `priority_queue`:

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;
using ll = long long;
const ll INF = 1e18;
int main() {
    int N, M, src;
    cin >> N >> M >> src;
    vector<vector<pair<int,int>>> adj(N);
    for(int i=0; i<M; i++){
        int u, v, w; 
        cin >> u >> v >> w;
        adj[u].push_back({v, w});
    }
    vector<ll> dist(N, INF);
    dist[src] = 0;
    // (distance, vertex)
    priority_queue<pair<ll,int>, vector<pair<ll,int>>, greater<>> pq;
    pq.push({0, src});
    while(!pq.empty()) {
        auto [d,u] = pq.top(); pq.pop();
        if(d > dist[u]) continue;
        for(auto [v,w] : adj[u]) {
            if(dist[v] > d + w) {
                dist[v] = d + w;
                pq.push({dist[v], v});
            }
        }
    }
    for(int i=0; i<N; i++){
        if(dist[i] == INF) cout << "INF ";
        else cout << dist[i] << " ";
    }
    return 0;
}
```



## 45. Командная строка. Работа с каталогами, файлами, системные команды

**Командная строка (CLI)** – текстовый интерфейс взаимодействия с операционной системой, где пользователь вводит команды в виде текстовых строк. В Windows это обычно `cmd.exe` (или PowerShell). Через командную строку можно управлять файлами, каталогами и выполнять системные утилиты.

* **Навигация по каталогам:**

  * `cd <каталог>` – сменить текущий каталог. Например, `cd C:\Windows` изменит рабочий каталог.
  * `dir` – показать список файлов и подпапок в текущем каталоге.
  * `md` или `mkdir` – создать новый каталог. `md NewFolder`.
  * `rd` или `rmdir` – удалить пустой каталог. `rmdir OldFolder`.
* **Управление файлами:**

  * `copy <src> <dst>` – копировать файл. `copy file1.txt file2.txt`.
  * `move <src> <dst>` – переместить/переименовать файл.
  * `del <имя>` (или `erase`) – удалить файл.
  * `type <имя>` – вывести содержимое текстового файла на экран.
  * `ren <старое> <новое>` – переименовать файл.
* **Системные команды:**

  * `ipconfig` – сведения о сетевых интерфейсах.
  * `ping`, `tracert` – диагностика сети.
  * `tasklist` / `taskkill` – показать/убить процессы.
  * `netstat` – статистика сетевых соединений.
  * `systeminfo` – информация о системе.
* **Перенаправление и конвейер:** с помощью `>` и `|` можно перенаправлять вывод команд. Например, `dir > list.txt` сохранит список файлов в файл.
* **Пример из C++:** можно вызвать команду ОС через `system()`:

  ```cpp
  #include <cstdlib>
  int main() {
      std::system("echo Текущий каталог:");
      std::system("cd C:\\");
      std::system("dir");
      return 0;
  }
  ```

  Это запускает команды как будто из консоли.



## 46. Командные файлы. Принципы написания. Примеры

**Командные файлы (batch-файлы)** – это текстовые скрипты Windows (с расширением `.bat` или `.cmd`), содержащие последовательность команд командной строки, выполняемых одна за другой. При запуске такого файла `cmd.exe` последовательно выполняет каждую команду в нём. Основные принципы и приёмы:

* **Структура:** первая строка обычно `@echo off` (отключает эхо вводимых команд). Команды пишутся построчно. Комментарии – строки, начинающиеся с `rem` или `::`.
* **Переменные:** `%VAR%` – содержимое переменной окружения; `%1`, `%2`… – параметры, переданные скрипту; `%~dp0` – путь к папке скрипта.
* **Управляющие конструкции:** `IF` (условный оператор), `GOTO` (прыжок к метке), `FOR` (цикл по файлам или списку), `CALL` (вызов другого .bat) и т.д.
* **Пример (batch-файл):**

  ```bat
  @echo off
  rem Пример простого скрипта
  echo Привет, %USERNAME%!
  if not exist C:\Temp mkdir C:\Temp
  copy "%~dp0example.txt" "C:\Temp"
  pause
  ```

  Этот скрипт выводит приветствие, создаёт папку C:\Temp (если нет), копирует файл `example.txt` из папки скрипта, и ждёт нажатием клавиши.
* **Полезные команды:** `echo` (вывод на экран), `set` (работа с переменными), `pause`, `exit`, `title` (заголовок окна), `start` (запуск приложения в новом окне), `schtasks` (задачи Планировщика) и др.



## 47. Системный реестр Windows. Составные части, размещение. Назначение разделов, виды и назначение параметров

**Реестр Windows** – иерархическая база данных настроек системы, приложений и оборудования. Вместо разбросанных текстовых конфигурационных файлов (как `.ini`) Windows использует реестр. Он состоит из «хивов» (файловой бэкап данных) и внутри них – веток (разделов) и параметров (значений).

* **Разделы (корневые ключи):**

  * `HKEY_CURRENT_USER (HKCU)` – содержит настройки и параметры текущего пользователя (профиля): обои, цвета, свойства папок, параметры ПО.
  * `HKEY_USERS (HKU)` – все загруженные профили пользователей. `HKCU` – это подраздел `HKU\<SID текущего пользователя>`.
  * `HKEY_LOCAL_MACHINE (HKLM)` – системные настройки компьютера (для всех пользователей): информация об оборудовании, установленных программах, системных службах.
  * `HKEY_CLASSES_ROOT (HKCR)` – ответвление, содержащее информацию об ассоциациях файлов и COM-классах. На самом деле объединяет `HKLM\Software\Classes` (настройки по умолчанию) и `HKCU\Software\Classes` (пользовательские переопределения). Здесь хранятся ProgID и команды "open" для типов файлов.
  * `HKEY_CURRENT_CONFIG (HKCC)` – параметры оборудования текущей конфигурации (ветвь, ссылающаяся на `HKLM\System\CurrentControlSet\Hardware Profiles\Current`).

Таблица основных ветвей реестра и их назначение:

| Корневой раздел | Назначение                                |
| --------------- | ----------------------------------------- |
| HKCU            | Настройки текущего пользователя (профиля) |
| HKU             | Все загруженные профили пользователей     |
| HKLM            | Системные настройки компьютера (для всех) |
| HKCR            | Ассоциации файлов, COM-классы (ProgID)    |
| HKCC            | Текущая конфигурация оборудования         |

* **Размещение (физические файлы):** для Windows NT/2000 и новее поддерживающие файлы хивов (обычно в `%SystemRoot%\System32\Config\`):

  * HKLM держится в файлах `SYSTEM`, `SOFTWARE`, `SAM`, `SECURITY`.
  * HKCU хранится в файле `NTUSER.DAT` в профиле пользователя.
  * (В старых версиях Windows: Windows XP – `SYSTEM.DAT` и `USER.DAT` и т.д.).

* **Типы параметров (значений):** у каждого ключа есть параметры вида `Name = data`. Различают типы данных параметров:

  * `REG_SZ` – обычная строка (null-terminated).
  * `REG_EXPAND_SZ` – расширяемая строка с переменными окружения (например, `%PATH%`).
  * `REG_MULTI_SZ` – массив строк (несколько строк через `\0`, завершается двойным `\0`).
  * `REG_DWORD` – 32-битное целое число (часто булевские или числовые флаги).
  * `REG_QWORD` – 64-битное целое.
  * `REG_BINARY` – бинарные данные в произвольном формате (например, настройки оборудования).
  * `REG_NONE` – без типа (реже используется).

Каждый тип служит своей цели: например, `REG_DWORD` удобно хранит числовые флаги (ключи вида `0x0`/`0x1`), а `REG_MULTI_SZ` – списки строк (списки путей, параметров).



## 48. Принципы обработки файлов различных типов, расширение оболочки Windows

Windows по-разному обрабатывает файлы в зависимости от **расширения** и связанных с ним настроек в реестре.

* **Ассоциации типов файлов:** для каждого расширения (например, `.txt`) в реестре есть ключ `HKCR\.txt`, который указывает на **ProgID** (например, `txtfile`). Затем в ключе `HKCR\txtfile\shell\open\command` хранится команда (строка запуска) для открытия такого файла (например, `"notepad.exe %1"`). Также там могут быть иконка, контекстные команды и т.д. Таким образом, при двойном клике или вызове `ShellExecute` система запускает связанный с типом файл процесс. При ассоциации нового приложения с типом меняются эти ключи (или создаются дополнительные ветви).
* **Контекстные меню и расширения Shell:** Windows Explorer может быть расширен «обработчиками оболочки» (Shell Extension) – COM-объектами, регистрируемыми в реестре. Это позволяют добавлять свои пункты в контекстное меню, изменять иконки, добавлять вкладки свойств и другие функции. Регистрируются они под ключами вида `HKCR\CLSID\{GUID}` (см. создание класса) и в специальных подразделах `ShellEx` ProgID или `HKCR\*\ShellEx`. Например, назначение пунктов меню задаётся через подкласс **verb** (команды), как `HKCR\txtfile\shell\print\command` – команда «Печать».
* **OpenSearch и нестандартные папки:** в Windows (начиная с Windows 7) можно подключать удалённые хранилища по протоколу OpenSearch. При этом для «виртуальных» элементов оболочки (не файлов) тоже определяется поведение через специальную регистрацию протоколов и команд .

**Пример:** чтобы зарегистрировать новое действие «Open With MyApp» для всех файлов без расширения, добавляют в реестр:

```reg
[HKEY_CLASSES_ROOT\*\shell\MyApp]
@="Open with MyApp"
"Icon"="MyApp.exe,0"
[HKEY_CLASSES_ROOT\*\shell\MyApp\command]
@="\"C:\\MyApp\\MyApp.exe\" \"%1\""
```

Это создаёт пункт меню «Open with MyApp» для всех файлов (`*`).

## 49. Принципы создания .reg и .inf файлов

**.reg-файл (Registration Entries)** – текстовый файл импорта реестра. Синтаксис: первая строка – версия реестра (`Windows Registry Editor Version 5.00` или `REGEDIT4` для устаревших ОС). Затем через пустую строку идут разделы `[HKEY_... ]` с ключами реестра, а в них – параметры в формате `"Имя"=Тип:Значение`. Пример .reg-файла:

```
Windows Registry Editor Version 5.00

[HKEY_CURRENT_USER\Software\MyApp]
"InstallPath"="C:\\Program Files\\MyApp"
"MaxCount"=dword:00000064
```

Здесь задаются два значения: строка `InstallPath` и DWORD `MaxCount`. При выполнении `.reg` эти записи добавятся в реестр.

**.inf-файл (Setup Information)** – текстовый файл, используемый для установки драйверов и некоторых компонентов Windows. Структурирован на разделы, обозначаемые `[SECTION]`. Основные разделы:

* `[Version]` – обязательный, включает `Signature="$WINDOWS NT$"` (указывает, что INF предназначен для NT-систем) и `Provider`, `Class` и т.д. Например:

  ```
  [Version]
  Signature="$Windows NT$"
  Provider=%MY_COMPANY%
  ```

  Поставщик определяется через строковый токен (%MY\_COMPANY%), задаваемый в секции `[Strings]`.
* `[DefaultInstall]` – инструкции по умолчанию для `rundll32 setupapi,InstallHinfSection DefaultInstall`.
* `[DestinationDirs]` – куда копировать файлы (например, `DefaultDestDir=10` – системная папка Windows).
* `[SourceDisksFiles]` – список файлов и с каких носителей их брать.
* `[DefaultInstall.Services]` и другие – для описания инсталляции служб или драйверов.
* **\[Strings]** – задаёт константы: после объявления `%MY_COMPANY% = "My Company Ltd."` подставляется в `[Version]`.

Пример `.inf`-фрагмента:

```
[Version]
Signature="$Windows NT$"
Provider=%MyVendor%

[DefaultInstall]
CopyFiles=MyDrivers

[SourceDisksFiles]
mydriver.sys=1

[DestinationDirs]
MyDrivers=10,system32\drivers

[MyDrivers]
mydriver.sys

[Strings]
MyVendor="ООО МойВендор"
```

Он указывает систему скопировать `mydriver.sys` в `C:\Windows\System32\drivers`.



## 50. RAID

**RAID** (Redundant Array of Independent Disks) – набор стандартных схем объединения нескольких дисков для повышения производительности и/или надёжности хранения данных. Основные уровни RAID:

* **RAID 0 (Striping)** – разбивает (чередует) данные на блоки и последовательно записывает на все диски без резервирования. Увеличивает скорость чтения/записи (дисков можно использовать параллельно), но **не даёт отказоустойчивости**: выход из строя любого диска приводит к потере данных. Требует минимум 2 диска.
* **RAID 1 (Mirroring)** – полное дублирование данных: каждый блок записывается на два (или более) диска одновременно. Размер массива равен размеру самого маленького диска в зеркальной паре. Обеспечивает отказоустойчивость: при выходе из строя одного из зеркал остальные хранят полную копию и массив продолжает работать. Запись медленнее одиночного диска, чтение потенциально быстрее (могут читаться разные копии). Требует минимум 2 дисков (полоса надёжности = 1).
* **RAID 5 (Striping с распределённым паритетом)** – чередование блоков и расчёт контрольной суммы (паритета) между дисками. Параметры разбросаны по всем дискам. Позволяет восстановить данные при отказе **одного** диска (потеря ёмкости равна размеру одного диска для хранения паритета). Минимум 3 диска.
* **RAID 6 (Striping с двойным паритетом)** – как RAID 5, но двукратный паритет: может пережить отказ **двух** дисков. Требует минимум 4 диска.
* **RAID 10 (1+0)** – зеркала, объединённые в страйп (составной): данные сначала зеркалируются попарно, а затем чередуются между парами. Сочетает скорость RAID 0 и надёжность RAID 1, но цена вдвое выше (50% полезной ёмкости). Мин. 4 диска.
* **Другие RAID:** есть и другие стандарты (0+1, 50, 60 и т.д.), сочетания зеркалирования, страйпинга, паритета.

Краткое сравнение (количество дисков \$n\$, сохраняемые при отказе – \$f\$):

| RAID | Описание                                   | Мин. дисков | Потеря при сбое                             |
| ---- | ------------------------------------------ | ----------: | ------------------------------------------- |
| 0    | Чередование (striping), без резервирования |           2 | 1 диск – всё погибает                       |
| 1    | Зеркалирование (mirroring)                 |           2 | \$n-1\$ (любые, кроме одного, могут упасть) |
| 5    | Чередование с распределённым паритетом     |           3 | 1 диск (потеря ёмкости = 1 диск)            |
| 6    | Чередование с двойным паритетом            |           4 | 2 диска                                     |
| 10   | Зеркала + чередование (stripe of mirrors)  |           4 | зависит от схемы (1 на пару)                |

Важно помнить, что RAID – это не замена бэкапа, он защищает только от аппаратных отказов отдельных дисков.

## 51. RAII

RAII (Resource Acquisition Is Initialization) — это идиома (подход) в языке программирования C++, основанная на том, что **ресурсы должны приобретаться и освобождаться в конструкторах и деструкторах объектов**. Это мощный механизм управления ресурсами, который тесно связан с концепцией **объектно-ориентированного программирования** и **детерминированного управления временем жизни объектов**.

---

## 💡 Суть RAII

В RAII идея заключается в следующем:

* **Приобретение ресурса** (например, памяти, файла, мьютекса, сокета и т.д.) происходит **в конструкторе** объекта.
* **Освобождение ресурса** происходит **в деструкторе** этого объекта.
* Таким образом, **ресурс существует ровно столько, сколько существует объект**.

RAII делает управление ресурсами **автоматическим, надёжным и исключающим утечки**, особенно в случае исключений.

---

## 🧱 Пример простого RAII-класса

```cpp
#include <iostream>
#include <fstream>

class FileRAII {
private:
    std::ofstream file;
public:
    FileRAII(const std::string& filename) {
        file.open(filename);
        if (!file.is_open()) {
            throw std::runtime_error("Failed to open file");
        }
        std::cout << "File opened\n";
    }

    void write(const std::string& text) {
        file << text;
    }

    ~FileRAII() {
        if (file.is_open()) {
            file.close();
            std::cout << "File closed\n";
        }
    }
};

int main() {
    try {
        FileRAII writer("output.txt");
        writer.write("Hello, RAII!");
    } catch (const std::exception& ex) {
        std::cerr << "Error: " << ex.what() << '\n';
    }
    return 0;
}
```

➡️ В этом примере:

* Файл открывается в конструкторе `FileRAII`.
* Если возникнет исключение в процессе работы, деструктор всё равно вызовется, и файл будет корректно закрыт.

---

## 🧰 Примеры ресурсов, с которыми работает RAII

| Ресурс         | Примеры классов/обёрток               |
| -------------- | ------------------------------------- |
| Память (heap)  | `std::unique_ptr`, `std::shared_ptr`  |
| Файлы          | `std::ifstream`, `std::ofstream`      |
| Мьютексы       | `std::lock_guard`, `std::scoped_lock` |
| Сокеты         | Кастомные RAII-классы                 |
| Дескрипторы ОС | RAII-обёртки в системных библиотеках  |

---

## 🧠 Почему RAII так важен?

### ✅ Автоматическое управление ресурсами

RAII **исключает утечки ресурсов** и делает код устойчивым к исключениям (англ. *exception-safe*).

### ✅ Простой и читаемый код

Вместо явного вызова `delete`, `fclose`, `unlock` и т.п., просто используешь объект — он сам всё сделает по завершении области видимости.

---

## 🎓 Использование RAII с `std::lock_guard`

```cpp
#include <mutex>

std::mutex mtx;

void thread_safe_function() {
    std::lock_guard<std::mutex> lock(mtx); // захват мьютекса
    // код, безопасный для многопоточности
} // автоматический unlock при выходе из области видимости
```

➡️ Мьютекс **всегда освобождается**, даже если внутри произойдет исключение — всё благодаря RAII.

---

## ⚠️ Без RAII: чем грозит?

```cpp
void unsafe_function() {
    FILE* file = fopen("data.txt", "w");
    if (!file) return;

    // что если здесь возникнет исключение?
    // fclose не вызовется → утечка ресурса

    fclose(file);
}
```

➡️ Без RAII **при возникновении исключений ресурсы утекут**, что ведёт к утечкам памяти, файлов, мьютексов и т.д.

---

## 🔚 Итог

**RAII в C++ — это не просто техника, а фундаментальный стиль управления ресурсами**, позволяющий писать безопасный, читаемый и устойчивый к ошибкам код.

Он основан на:

* **Конструкторе** для захвата ресурса
* **Деструкторе** для освобождения
* **Автоматическом управлении временем жизни объекта**

Практически весь современный C++ код и стандартная библиотека активно используют RAII.

Хочешь примеры с `unique_ptr`, `shared_ptr` или кастомную реализацию?
